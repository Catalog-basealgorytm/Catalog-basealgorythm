from app import app, db
from models import Algorithm

def add_algo(data):
    with app.app_context():
        algo = Algorithm(**data)
        db.session.add(algo)
        db.session.commit()
        print(f"✅ Додано: {algo.name}")
add_algo({
    "name": "Структура Даних: Стек (Stack)",
    "category": "Структури Даних",
    "description": """Стек – це абстрактний тип даних та лінійна структура даних, що працює за принципом **LIFO (Last-In, First-Out)**, що означає "останнім прийшов – першим вийшов". Уявіть собі стопку тарілок: ви можете додавати нову тарілку тільки зверху і брати тарілку також тільки зверху.

Основні операції зі стеком включають додавання елемента на вершину стека (push) та видалення елемента з вершини стека (pop). Також часто реалізують операцію перегляду верхнього елемента без його видалення (peek або top) та перевірку, чи стек порожній.

Стеки широко використовуються в програмуванні для різноманітних завдань, таких як управління викликами функцій (стек викликів), розбір виразів (наприклад, у компіляторах), реалізація алгоритмів пошуку в глибину (DFS) на графах або деревах, а також для реалізації функції "скасувати" (undo) в програмах.""",
    "pseudocode": """// Основні операції зі стеком
// Ініціалізація стека
ФУНКЦІЯ СтворитиСтек()
  створити порожній стек S
  ПОВЕРНУТИ S
КІНЕЦЬ ФУНКЦІЇ

// Додавання елемента на вершину стека
ПРОЦЕДУРА Push(стек S, елемент X)
  додати X на вершину стека S
КІНЕЦЬ ПРОЦЕДУРИ

// Видалення та повернення елемента з вершини стека
ФУНКЦІЯ Pop(стек S)
  ЯКЩО СтекПорожній(S) ТОДІ
    ВИДАТИ ПОМИЛКУ "Стек порожній"
  ІНАКШЕ
    X = елемент_на_вершині(S)
    видалити_елемент_з_вершини(S)
    ПОВЕРНУТИ X
  КІНЕЦЬ ЯКЩО
КІНЕЦЬ ФУНКЦІЇ

// Перегляд верхнього елемента стека (без видалення)
ФУНКЦІЯ Peek(стек S)
  ЯКЩО СтекПорожній(S) ТОДІ
    ВИДАТИ ПОМИЛКУ "Стек порожній"
  ІНАКШЕ
    ПОВЕРНУТИ елемент_на_вершині(S)
  КІНЕЦЬ ЯКЩО
КІНЕЦЬ ФУНКЦІЇ

// Перевірка, чи стек порожній
ФУНКЦІЯ СтекПорожній(стек S)
  ПОВЕРНУТИ (кількість_елементів_в(S) == 0)
КІНЕЦЬ ФУНКЦІЇ""",
    "implementation": """# Реалізація Стека на основі списку Python
class Stack:
    def __init__(self):
        self._items = []  # Використовуємо приватний атрибут для зберігання елементів

    def push(self, item):
        \"\"\"Додає елемент на вершину стека.\"\"\"
        self._items.append(item)

    def pop(self):
        \"\"\"Видаляє та повертає елемент з вершини стека.
        Викликає помилку IndexError, якщо стек порожній.\"\"\"
        if not self.is_empty():
            return self._items.pop()
        else:
            raise IndexError("pop from empty stack")

    def peek(self):
        \"\"\"Повертає елемент з вершини стека без його видалення.
        Викликає помилку IndexError, якщо стек порожній.\"\"\"
        if not self.is_empty():
            return self._items[-1]
        else:
            raise IndexError("peek from empty stack")

    def is_empty(self):
        \"\"\"Перевіряє, чи стек порожній.\"\"\"
        return len(self._items) == 0

    def size(self):
        \"\"\"Повертає кількість елементів у стеку.\"\"\"
        return len(self._items)

# Приклад використання:
# my_stack = Stack()
# my_stack.push(1)
# my_stack.push(5)
# print(my_stack.peek())  # Виведе: 5
# print(my_stack.pop())   # Виведе: 5
# print(my_stack.is_empty()) # Виведе: False
# print(my_stack.pop())   # Виведе: 1
# print(my_stack.is_empty()) # Виведе: True
""",
    "complexity": """**Часова складність основних операцій (для реалізації на основі динамічного масиву/списку Python):**
* `push()`: $O(1)$ (в середньому, амортизована складність, оскільки іноді може знадобитися розширення масиву)
* `pop()`: $O(1)$
* `peek()`: $O(1)$
* `is_empty()`: $O(1)$
* `size()`: $O(1)$

**Просторова складність:**
* $O(n)$, де $n$ - кількість елементів у стеку.""",
    "usage": """Стеки є фундаментальною структурою даних і знаходять застосування в багатьох задачах програмування:
* **Управління викликами функцій (Стек викликів):** Коли функція викликає іншу функцію, інформація про поточну функцію (адреса повернення, локальні змінні) зберігається у стеку викликів.
* **Обчислення виразів:** Перетворення інфіксних виразів у постфіксні (зворотний польський запис) або префіксні, та їх подальше обчислення.
* **Парсинг та компілятори:** Аналіз синтаксису мов програмування.
* **Алгоритм пошуку в глибину (DFS):** Для обходу дерев та графів.
* **Реалізація функції "Скасувати" (Undo):** Зберігання послідовності станів або дій для можливості їх скасування.
* **Перевірка збалансованості дужок:** Визначення, чи правильно розставлені дужки у виразі (наприклад, `{[()]}()` ).
* **Моделювання рекурсії:** Ітеративна реалізація рекурсивних алгоритмів часто використовує явний стек."""
})