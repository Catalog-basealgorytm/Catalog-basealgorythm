from app import app, db
from models import Algorithm

def add_algo(data):
    with app.app_context():
        algo = Algorithm(**data)
        db.session.add(algo)
        db.session.commit()
        print(f"✅ Додано: {algo.name}")
add_algo({
    "name": "Сортування Злиттям (Merge Sort)",
    "category": "Сортування",
    "description": """Сортування злиттям – це елегантний та ефективний алгоритм, що базується на стратегії "розділяй та володарюй". Уявіть, що вам потрібно впорядкувати велику кількість карток. Замість того, щоб намагатися впоратися з усією купою одразу, ви застосовуєте розумніший підхід.

Спочатку ви розділяєте вашу основну задачу на менші, більш керовані підзадачі. Це означає, що ви ділите масив (або список елементів, який потрібно відсортувати) приблизно навпіл. Потім кожну з цих половин ви знову ділите навпіл, і так продовжуєте цей процес рекурсивно, аж доки у вас не залишаться окремі елементи. Один елемент, очевидно, вже є відсортованим сам по собі!

Наступний етап – це "володарюй" або, точніше, злиття (комбінування). Тепер, коли у вас є багато маленьких "відсортованих" частинок (окремих елементів), ви починаєте їх об'єднувати. Ви берете дві сусідні відсортовані частинки і зливаєте їх в одну більшу, але вже також відсортовану частинку. Це робиться шляхом послідовного порівняння елементів з обох частинок і додавання меншого (або більшого, залежно від порядку сортування) до нової, об'єднаної послідовності. Цей процес злиття продовжується, об'єднуючи все більші й більші відсортовані сегменти, доки весь початковий масив не стане повністю відсортованим.""",
    "pseudocode": """mergeSort(arr):
    if len(arr) > 1:
        mid = len(arr) // 2
        L = arr[:mid]
        R = arr[mid:]
        mergeSort(L)
        mergeSort(R)
        merge(arr, L, R)""",
    "implementation": """def merge_sort(arr):
    if len(arr) > 1:
        mid = len(arr) // 2
        L = arr[:mid]
        R = arr[mid:]
        merge_sort(L)
        merge_sort(R)
        i = j = k = 0
        while i < len(L) and j < len(R):
            if L[i] < R[j]:
                arr[k] = L[i]
                i += 1
            else:
                arr[k] = R[j]
                j += 1
            k += 1
        while i < len(L):
            arr[k] = L[i]
            i += 1
            k += 1
        while j < len(R):
            arr[k] = R[j]
            j += 1
            k += 1""",
    "complexity": """**Часова складність:**
Найгірший, середній та найкращий випадки: $O(n \log n)$. Це означає, що час сортування зростає пропорційно до $n \cdot \log n$, де $n$ - кількість елементів.
($\log n$ рівнів рекурсії, на кожному з яких виконуються $n$ операцій злиття).

**Просторова складність:**
$O(n)$ у класичній реалізації через потребу в додатковому масиві для злиття.""",
    "usage": """Сортування злиттям є універсальним і широко використовуваним алгоритмом завдяки своїй ефективності та стабільності.
* **Сортування великих наборів даних:** Добре підходить для масивів, які не вміщуються повністю в оперативну пам'ять (зовнішнє сортування).
* **Сортування зв'язаних списків:** Особливо ефективне, оскільки вставка та злиття елементів у списку може виконуватися за $O(1)$ по пам'яті.
* **Стабільне сортування:** Зберігає відносний порядок елементів з однаковими значеннями (корисно для сортування таблиць за кількома колонками).
* **Підрахунок інверсій:** Модифікована версія використовується для ефективного підрахунку інверсій.
* **Застосування в інших алгоритмах:** Принцип злиття є частиною складніших алгоритмів.
* **Освітні цілі:** Класичний приклад алгоритму "розділяй та володарюй"."""
})